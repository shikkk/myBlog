# js内存管理机制

## js内存生命周期

名称|描述
:--|:--|
分配内存|给当前要使用的数据分配内存空间
内存的读与写|内存空间中放入要存储的数据，可以对其数据读取和更改
内存释放|数据用完的把内存释放了

## 栈内存和堆内存

内存|数据类别|数据类型|描述
:--|:--|:--|:--|
栈内存|基本数据类型|String，Number，Boolean，null，undefined，Symbol|特征大小固定，体积轻量，相对简单
堆内存|引用数据类型|Object，Array，Function|特征占用空间大，且大小不固定

## 垃圾回收机制

### 1.引用计数法
如下例子：  
```js
const me = ['s', 'z', 'k']
```
1. 当用一个变量指向一个值，那就创建了一个针对这个值的 “引用”
2. 赋值表达式从右往左读
3. 首先是开辟了一块内存，把右边的数组塞进去，此时这数组占据了一块内存
4. 随后`me`变量指向它，这就是创建了一个该值的“引用”
5. 此时数组的引用计数就是 1
6. 在引用计数法的机制下，内存中每个值都会对应一个引用计数
7. 当垃圾收集器感知到某个值为0，就会把这块内存释放

```js
const me = null  // 引用计数为0，释放内存
```

### 2.标记清除法
2012年起，所有浏览器使用了标记清除算法
<div style="width: 80px">阶段</div>|描述
:--|:--|
标记阶段|垃圾收集器会先找到根对象，在浏览器里是`window`,node里是`Global`,垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为‘可抵达’
清楚阶段|没有被标记‘可抵达’的变量，会被认为是不需要的变量，这些变量会被清除

## 内存泄漏
该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃一些连问题

### 内存泄漏的成因

1. “手滑”导致全局变量
```js
function me() {
  name = 'szk'
}
```
会挂载到全局对象上

2. 忘记清楚的 setInterval 和 setTimeout

不用的时候需要自行clear函数

